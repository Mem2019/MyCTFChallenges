#include "TrieTreeStatic.h"
#include "TrieTree.h"
#include <cstdio>

#define RESULT_MSG_LEN 16

#define ANSWER_LEN 22
#define ANSWER_BUF_LEN (ANSWER_LEN+1)
#define INPUT_BUF_LEN 32

TrieTreeStatic answerTree(nullptr);

TrieTreeNodeStatic node_f;
TrieTreeNodeStatic node_t;
TrieTreeNodeStatic node_M;
TrieTreeNodeStatic node_7;
TrieTreeNodeStatic node_9;
TrieTreeNodeStatic node_k;
TrieTreeNodeStatic node_c;
TrieTreeNodeStatic node_kx;
TrieTreeNodeStatic node_root;

void output(const char* msgA)
{
	cout << msgA << endl;
}

void getAnswerIsWrong(char* szDesP)
//pre: the szDes must have size 16
{
	unsigned char* szDes = (unsigned char*)szDesP;
	szDes[0] = 141;
	szDes[1] = 180;
	szDes[2] = 251;
	szDes[3] = 69;
	szDes[4] = 81;
	szDes[5] = 152;
	szDes[6] = 144;
	szDes[7] = 139;
	szDes[8] = 175;
	szDes[9] = 218;
	szDes[10] = 207;
	szDes[11] = 96;
	szDes[12] = 171;
	szDes[13] = 100;
	szDes[14] = 39;
	szDes[15] = 0;
	for (unsigned int i = 0; i < 15; i++)
	{
		szDes[i] ^= (unsigned char)(0x3a * i*i*i + 0x22 * i*i + 0xb2 * i + 0xcc);
	}
}

void getAnswerCorrect(char* szDesP)
//pre: the szDes must have size 16
{
	unsigned char* szDes = (unsigned char*)szDesP;
	szDes[0] = 192;
	szDes[1] = 187;
	szDes[2] = 248;
	szDes[3] = 148;
	szDes[4] = 120;
	szDes[5] = 11;
	szDes[6] = 23;
	szDes[7] = 244;
	szDes[8] = 182;
	szDes[9] = 79;
	szDes[10] = 113;
	szDes[11] = 14;
	szDes[12] = 214;
	szDes[13] = 85;
	szDes[14] = 206;
	szDes[15] = 0;
	for (unsigned int i = 0; i < 15; i++)
	{
		szDes[i] ^= (unsigned char)(0x60 * i*i*i + 0x11 * i*i + 0xe3 * i + 0x81);
	}
}

void getStr_c(char* szDesP)
//pre: the szDes must have size 2
{
	unsigned char* szDes = (unsigned char*)szDesP;
	szDes[0] = 114;
	szDes[1] = 0;
	for (unsigned int i = 0; i < 1; i++)
	{
		szDes[i] ^= (unsigned char)(0x6d * i*i*i + 0x64 * i*i + 0xaf * i + 0x11);
	}
}

void getStr_t(char* szDesP)
//pre: the szDes must have size 2
{
	unsigned char* szDes = (unsigned char*)szDesP;
	szDes[0] = 195;
	szDes[1] = 0;
	for (unsigned int i = 0; i < 1; i++)
	{
		szDes[i] ^= (unsigned char)(0x68 * i*i*i + 0x9e * i*i + 0x56 * i + 0xb7);
	}
}

void getStr_f(char* szDesP)
//pre: the szDes must have size 2
{
	unsigned char* szDes = (unsigned char*)szDesP;
	szDes[0] = 104;
	szDes[1] = 0;
	for (unsigned int i = 0; i < 1; i++)
	{
		szDes[i] ^= (unsigned char)(0x95 * i*i*i + 0x92 * i*i + 0x16 * i + 0xe);
	}
}

void getStr_7(char* szDesP)
//pre: the szDes must have size 2
{
	unsigned char* szDes = (unsigned char*)szDesP;
	szDes[0] = 81;
	szDes[1] = 0;
	for (unsigned int i = 0; i < 1; i++)
	{
		szDes[i] ^= (unsigned char)(0x68 * i*i*i + 0xf5 * i*i + 0x3b * i + 0x66);
	}
}

void getStr_M(char* szDesP)
//pre: the szDes must have size 2
{
	unsigned char* szDes = (unsigned char*)szDesP;
	szDes[0] = 171;
	szDes[1] = 0;
	for (unsigned int i = 0; i < 1; i++)
	{
		szDes[i] ^= (unsigned char)(0xe8 * i*i*i + 0x51 * i*i + 0x84 * i + 0xe6);
	}
}

void getStr_k(char* szDesP)
//pre: the szDes must have size 2
{
	unsigned char* szDes = (unsigned char*)szDesP;
	szDes[0] = 25;
	szDes[1] = 0;
	for (unsigned int i = 0; i < 1; i++)
	{
		szDes[i] ^= (unsigned char)(0x26 * i*i*i + 0x3 * i*i + 0x77 * i + 0x72);
	}
}

void getStr_kx(char* szDesP)
//pre: the szDes must have size 3
{
	unsigned char* szDes = (unsigned char*)szDesP;
	szDes[0] = 70;
	szDes[1] = 214;
	szDes[2] = 0;
	for (unsigned int i = 0; i < 2; i++)
	{
		szDes[i] ^= (unsigned char)(0x88 * i*i*i + 0x2d * i*i + 0xcc * i + 0x2d);
	}
}

void getStr_9(char* szDesP)
//pre: the szDes must have size 2
{
	unsigned char* szDes = (unsigned char*)szDesP;
	szDes[0] = 49;
	szDes[1] = 0;
	for (unsigned int i = 0; i < 1; i++)
	{
		szDes[i] ^= (unsigned char)(0x74 * i*i*i + 0x5e * i*i + 0xef * i + 0x8);
	}
}
//these function is auto generated by a python script
//so the important string will be generated dynamically
//instead of in the .rodata section

void getStrMessageBoxTimeoutW(char* szDesP)
//pre: the szDes must have size 19
{
	unsigned char* szDes = (unsigned char*)szDesP;
	szDes[0] = 220;
	szDes[1] = 230;
	szDes[2] = 156;
	szDes[3] = 224;
	szDes[4] = 76;
	szDes[5] = 28;
	szDes[6] = 94;
	szDes[7] = 105;
	szDes[8] = 102;
	szDes[9] = 235;
	szDes[10] = 211;
	szDes[11] = 202;
	szDes[12] = 200;
	szDes[13] = 46;
	szDes[14] = 60;
	szDes[15] = 14;
	szDes[16] = 245;
	szDes[17] = 116;
	szDes[18] = 0;
	for (unsigned int i = 0; i < 18; i++)
	{
		szDes[i] ^= (unsigned char)(0xf5 * i*i*i + 0x5e * i*i + 0x9f * i + 0x91);
	}
}
class A
{
public:
	A()
	{
		char str_c[2];
		char str_k[2];
		char str_7[2];
		char str_M[2];
		char str_f[2];
		char str_9[2];
		char str_kx[3];
		char str_t[2];

		getStr_f(str_f);
		getStr_t(str_t);
		getStr_M(str_M);
		getStr_7(str_7);
		getStr_9(str_9);
		getStr_k(str_k);
		getStr_c(str_c);
		getStr_kx(str_kx);
		//get the string dynamically
		//so that these string will not appear in the .rodata

		node_9.setContent(str_9);
		node_M.setContent(str_M);
		node_k.setContent(str_k);
		node_c.setContent(str_c);
		node_7.setContent(str_7);
		node_t.setContent(str_t);
		node_kx.setContent(str_kx);
		node_f.setContent(str_f);
		//set the content of the Trie Tree Node

		node_M.addChild(&node_k);
		node_t.addChild(&node_9);
		node_7.addChild(&node_M);
		node_t.addChild(&node_f);
		node_c.addChild(&node_7);
		node_root.addChild(&node_kx);
		node_c.addChild(&node_t);
		node_root.addChild(&node_c);
		//build the trie tree

		node_c.setNumber(0);
		node_k.setNumber(1);
		node_9.setNumber(1);
		node_t.setNumber(1);
		node_7.setNumber(1);
		node_M.setNumber(2);
		node_root.setNumber(0);
		node_f.setNumber(1);
		node_kx.setNumber(1);
		//set the frequency

		answerTree.setRoot(&node_root);
	}
};
A a;

void thirdCheck(char* c7, char* kx, char* ctf,
	char* ct9, const char* szCor, const char* szWrong)
{
	if ((c7[0] ^ c7[1]) == ('c'^'7') &&
		(kx[0] ^ kx[1]) == ('x'^'k') &&
		(ctf[2] ^ ctf[1]) == ('f'^'t') &&
		(ct9[1] ^ ct9[2]) == ('t'^'9'))
		output(szCor);
	else
		output(szWrong);
	/*
	>>> ord('c')^ord('7')
	84
	>>> ord('k')^ord('x')
	19
	>>> ord('c')^ord('t')
	23
	>>> ord('M')^ord('7')
	122
	>>> ord('f')^ord('t')
	18
	>>> ord('t')^ord('9')
	77
	*/
}

void secondCheck(char* input, const char* szCor, const char* szWrong)
{
	char c7M[4];
	char c7[3];
	char ctf[4];
	char c7M2[4];
	char c7Mk[5];
	char ct[3];
	char ct9[4];
	char kx[3];

	c7[2] = 0;
	ct[0] = input[2];
	c7M2[3] = 0;
	c7[1] = input[1];
	c7Mk[3] = input[12];
	ct9[0] = input[16];
	c7Mk[0] = input[9];
	kx[0] = input[7];
	c7Mk[1] = input[10];
	kx[1] = input[8];
	c7M[1] = input[20];
	c7Mk[4] = 0;
	ctf[2] = input[15];
	ct[2] = 0;
	kx[2] = 0;
	c7M2[2] = input[6];
	ctf[1] = input[14];
	c7M2[0] = input[4];
	ct[1] = input[3];
	ctf[0] = input[13];
	ct9[3] = 0;
	c7M2[1] = input[5];
	ct9[1] = input[17];
	c7[0] = input[0];
	c7M[2] = input[21];
	ctf[3] = 0;
	c7M[0] = input[19];
	c7Mk[2] = input[11];
	ct9[2] = input[18];
	c7M[3] = 0;
	//seperate the input into serveral sections
	//shuffle the order, so more difficult to reverse
	//I don't use things like substring, that will make it easy to reverse
	TrieTree rt;
	rt.addString(ctf);
	rt.addString(c7);
	rt.addString(c7Mk);
	rt.addString(c7M2);
	rt.addString(ct);
	rt.addString(kx);
	rt.addString(ct9);
	rt.addString(c7M);
	//add the sections into RadixTree
	if (rt == answerTree)
	{//if tree is equal, do the third check
		thirdCheck(c7, kx, ctf, ct9, szCor, szWrong);
	}
	else
	{
		output(szWrong);
	}
}

bool isDigit(char c)
{
	return c >= ('0') && c <= ('9');
}

bool isLetter(char c)
{
	return (c | 32) >= ('a') && (c | 32) <= ('z');
}

bool checkCharRange(char* str, const char* szWrong)
{
	int len = strlen(str);
	for (int i = 0; i < len; i++)
	{
		if (!isLetter(str[i]) && !isDigit(str[i]))
		{
			output(szWrong);
			return false;
		}
	}
	return true;
}
int main()
{
	char input[INPUT_BUF_LEN];
	scanf_s("%s", input, INPUT_BUF_LEN);

	char szCorrectA[RESULT_MSG_LEN];
	char szWrongA[RESULT_MSG_LEN];
	getAnswerCorrect(szCorrectA);
	getAnswerIsWrong(szWrongA);

	if (!checkCharRange(input, szWrongA))
	{
		memset(szCorrectA, 0, RESULT_MSG_LEN);
		memset(szWrongA, 0, RESULT_MSG_LEN);
		return 0;
	}

	if (strlen(input) != ANSWER_LEN)
	{
		output(szWrongA);
	}
	else
	{
		secondCheck(input, szCorrectA, szWrongA);
	}

	memset(szWrongA, 0, RESULT_MSG_LEN);
	memset(szCorrectA, 0, RESULT_MSG_LEN);
	system("pause");
	return 0;
}